// SPDX-License-Identifier: MIT
pragma solidity^0.8.1;


import "./price.sol";
import "../../node_modules/@chainlink/contracts/src/v0.8/KeeperCompatible.sol";


interface btgDOL {
    function balanceOf(address _address) external view returns(uint256);
    function transferFrom(address _from, address _to, uint _amout) external returns(bool);
}

contract OptionsList {
    address[] public deployedOptions;

    function createOption(address _opcAddr) public {
        deployedOptions.push(_opcAddr);
    }

    function getDeployedCampaigns() public view returns (address [] memory) {
        return deployedOptions;
    }
}

contract btgOpc is KeeperCompatibleInterface {

    //address private btgdolAddr = 0x41b4eb8323e97C814f4A0aee07e2C8f226291e81;  0x45e0C7F0790f501a92c52bbC59bE6C8ae85bf722
    PriceConsumerV3 public priceEth;

    uint public ethPrice;
    address public addr = 0x0172ae13E3583BF565957095D27caede3Abb172e;
    uint256 lastTimeStamp;
    uint256 interval;

    OptionsList public optList;
    
    struct buyRequest {
        address buyer;
        uint value;
    }

    buyRequest [] public buyersList;

    mapping(address => bool) canBuy;

    struct opcDol {
            uint strike; // eth em dolar
            uint dataVencimento;
            uint valorCobertura;// numero de eths
            uint emissionPrice;// acho que nao precisa
            uint actualPrice; //acho q nao precisa
            string description;
            bool valid;
            address emissor;
            address buyer;
    }
    
    opcDol public opc;

    constructor (uint _strike, uint _date, uint _prizePrice, string memory _description, uint _value, address _chainlinkPriceAddr, address _optionslistAddr) payable {
        
        require(btgDOL(addr).balanceOf(msg.sender) >= _value, "You should have on wallet at least the same ammout of eth on wallet as you want to cover on your option");
        require(msg.value == _value, "You need to lock your ethers in the period the option is being valid");
        
        optList = OptionsList(_optionslistAddr);
        priceEth = PriceConsumerV3(_chainlinkPriceAddr);
        ethPrice = uint(priceEth.getLatestPrice());

        opc = opcDol ({
            strike: _strike,
            dataVencimento: _date,
            valorCobertura: _value,
            emissionPrice: _prizePrice,
            actualPrice: _prizePrice,
            description: _description,
            valid: true,
            emissor: msg.sender,
            buyer: msg.sender
        });

        optList.createOption(address(this));


    }


    function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        bool done;
        done = true;
        upkeepNeeded = !done && ((block.timestamp - lastTimeStamp) > interval);        
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        ethPrice = uint(priceEth.getLatestPrice());
        
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    function creatBuyRequest(uint _value) public payable{
        require(btgDOL(addr).balanceOf(msg.sender) > _value, "you dont have enought tokens");
        buyRequest memory newRequest = buyRequest({
            buyer: msg.sender,
            value: _value
        });

        buyersList.push(newRequest);
    }

    function aproveRequest(uint _index) public {
        require(msg.sender == opc.buyer, "You should be the option owner to call this function");
        address add = buyersList[_index].buyer;
        canBuy[add] = true;
    }
    
    function buyOpc(uint _price) public payable {
        require(btgDOL(addr).balanceOf(msg.sender) >= _price, "You dont't have enought tokens to buy this option");
        require(canBuy[msg.sender], "Your buy request was not approved");
        //require(_price >= opc.actualPrice, "The price you are ofering is lower than the Prize Price...");
        btgDOL(addr).transferFrom(msg.sender, opc.emissor, _price);
        opc.buyer = msg.sender;
    }

    function executeOpc() public payable returns(string memory _status){
        require(msg.sender == opc.buyer, "Only the owner of the option can execute it");
        require(btgDOL(addr).balanceOf(msg.sender) >= opc.strike, "You don't have enought tokens to make the transaction"); // se a btgUsd criar uma funcao de convesao automatica essa condicao pode ser ignorada
        if(ethPrice > opc.strike){
            btgDOL(addr).transferFrom(msg.sender, opc.emissor, opc.strike);
            payable(msg.sender).transfer(address(this).balance);
            _status = "The option has been executed check your balance";
            return _status;
        }else {
            _status = "There's no sense in executing the option since it will return a loss";
            return _status;
        }
    }

}

//eh um contrato onde voce emite um direito de compra ou venda que pode ser adiquirido por alguem
// ao ser vendido para alguem o comprador tem o direito de comprar as suas acoes ou produto no preço acordado
// Exemplo: vendo uma opção que da ao comprador o direito de comprar meus dolares a 5 reais com o vencimento para o mes que vem
// se na data de vencimento o dolar estiver valendo 5.5 o comprador da opc pode executar seu direito de compra e comprar meus dolares por 5 reais
// isso fara com que ele lucre 0.5 dolares por opcao adiquirida, se o preço do dolar for menor que 5 reais no caso de uma opcao de compra essa opcao vira po
// pois nao faria sentido comprar o dolar a 5 reais sendo que ele vale 4.50 por exemplo


// Criar uma opcao de dolar utilizando o btgDol
// Fazer com que uma opcao equivalha a um preço de forma que o btgDol fique travado no contrato e seja emitido um token de wrapped BTGDol
// O btgDol vai ser enviado ao dono da opcao a um determinado preço e ele podera vender ou não no preço de mercado
// A principio a opcao de dolar deve ser um struct que vai ser adcionado a uma lista de opçoes, vc pode emitir uma opção ou comprar uma que esteja a venda